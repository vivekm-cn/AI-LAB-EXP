from collections import deque

def solve_water_jug(jug1_cap, jug2_cap, target):
    q = deque([((0, 0), [])]) # ((jug1, jug2), path)
    visited = set([(0, 0)])

    while q:
        (state, path) = q.popleft()
        jug1, jug2 = state

        if jug1 == target or jug2 == target:
            print("Water Jug Solution Found:")
            for p in path:
                print(p)
            print(f"Final state: {state}")
            return

        # Possible next states
        successors = [
            ((jug1_cap, jug2), f"Fill Jug 1"),          # 1. Fill Jug 1
            ((jug1, jug2_cap), f"Fill Jug 2"),          # 2. Fill Jug 2
            ((0, jug2), f"Empty Jug 1"),               # 3. Empty Jug 1
            ((jug1, 0), f"Empty Jug 2"),               # 4. Empty Jug 2
            # 5. Pour Jug 1 to Jug 2
            ((max(0, jug1 - (jug2_cap - jug2)), min(jug2_cap, jug2 + jug1)), "Pour J1 to J2"),
            # 6. Pour Jug 2 to Jug 1
            ((min(jug1_cap, jug1 + jug2), max(0, jug2 - (jug1_cap - jug1))), "Pour J2 to J1")
        ]

        for next_state, action in successors:
            if next_state not in visited:
                visited.add(next_state)
                new_path = path + [f"Action: {action}, State: {state}"]
                q.append((next_state, new_path))
    
    print("No solution found.")

# --- Example Usage ---
# Goal: Measure 4 liters using a 5-liter jug and a 3-liter jug
solve_water_jug(5, 3, 4)
